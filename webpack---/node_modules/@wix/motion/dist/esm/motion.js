import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { scrollAnimations } from './library/scroll';
import { entranceAnimations } from './library/entrance';
import { ongoingAnimations } from './library/ongoing';
import { mouseAnimations } from './library/mouse';
import { backgroundScrollAnimations } from './library/backgroundScroll';
import { getCssUnits, getEasing, getJsEasing } from './utils';
import fastdom from 'fastdom';
function getDirection(effect) {
  const alternate = effect.alternate ? 'alternate' : '';
  return effect.reversed ? `${alternate ? `${alternate}-` : ''}reverse` : alternate || 'normal';
}
function getLength(length) {
  return `${length.value}${getCssUnits(length.type)}`;
}
function getRange(range, add, isEnd) {
  // according to the CSS spec if the end range is a <length> then it is calculated from the start of the named range
  // our model assumes that <length> in end range is calculated from the end of the named range
  return `${range.name} ${isEnd && range.offset.type !== 'percentage' ? `calc(100% + ${getLength(range.offset)}${add ? ` + ${add}` : ''})` : add ? `calc(${getLength(range.offset)} + ${add})` : getLength(range.offset)}`;
}
function getRanges(effect) {
  return {
    start: getRange(effect.startOffset, effect.startOffsetAdd),
    end: getRange(effect.endOffset, effect.endOffsetAdd, true)
  };
}
function getElement(id) {
  return id ? document.getElementById(id) : null;
}
function measure(target) {
  return fn => fastdom.measure(() => fn(target));
}
function mutate(target) {
  return fn => fastdom.mutate(() => fn(target));
}
function getAnimationTarget(target, part) {
  return target ? `#${target}${part ? `[data-motion-part~="${part}"]` : ''}` : '';
}
function getAnimationAsCSS(data) {
  const {
    duration,
    delay,
    iterations = 1,
    fill,
    easing = 'linear',
    direction,
    composite
  } = data.options;
  const animationName = data.effect.name;
  return `${animationName} ${duration === 'auto' ? 'auto' : `${duration}ms`}${delay ? ` ${delay}ms` : ''} ${easing}${fill && fill !== 'none' ? ` ${fill}` : ''} ${iterations || 'infinite'}${direction === 'normal' ? '' : ` ${direction}`}${composite ? ` ${composite}` : ''}`;
}
function getNamedEffect(animation) {
  if (animation.namedEffect) {
    const name = animation.namedEffect.type;

    // check each preset library for the named effect
    if (name in scrollAnimations) {
      return scrollAnimations[name];
    } else if (name in entranceAnimations) {
      return entranceAnimations[name];
    } else if (name in ongoingAnimations) {
      return ongoingAnimations[name];
    } else if (name in mouseAnimations) {
      return mouseAnimations[name];
    } else if (name in backgroundScrollAnimations) {
      return backgroundScrollAnimations[name];
    }
  } else if (animation.customEffect) {
    return animation_ => [{
      ...animation_,
      keyframes: []
    }];
  }
  return null;
}
function getWebAnimationEffect(preset, animation, target, options) {
  if (preset) {
    let domApi;
    if (target instanceof HTMLElement) {
      domApi = {
        measure: measure(target),
        mutate: mutate(target)
      };
    }

    // validate duration is a number over 0
    if (animation.type === 'TimeAnimationOptions') {
      animation.duration = animation.duration || 1;
    }
    return preset.web ? preset.web(animation, domApi, options) : preset(animation, domApi, options);
  }
  return [];
}
function getCSSAnimationEffect(preset, animation) {
  if (preset) {
    // validate duration is a number over 0
    if (animation.type === 'TimeAnimationOptions') {
      animation.duration = animation.duration || 1;
    }
    return preset.style(animation);
  }
  return [];
}

/**
 * @class AnimationGroup
 *
 * A wrapper object for simulating a GroupEffect and managing multiple animations.
 * See: https://www.w3.org/TR/web-animations-2/#grouping-and-synchronization
 */
class AnimationGroup {
  constructor(animations, options) {
    _defineProperty(this, "animations", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "ready", void 0);
    this.animations = animations;
    this.options = options;
    this.ready = (options == null ? void 0 : options.measured) || Promise.resolve();
  }
  getProgress() {
    var _this$animations$0$ef;
    return ((_this$animations$0$ef = this.animations[0].effect) == null ? void 0 : _this$animations$0$ef.getComputedTiming().progress) || 0;
  }
  play(callback) {
    this.ready.then(() => {
      for (const animation of this.animations) {
        animation.play();
      }
    }).then(() => Promise.all(this.animations.map(animation => animation.ready))).then(callback);
  }
  pause() {
    for (const animation of this.animations) {
      animation.pause();
    }
  }
  reverse(callback) {
    this.ready.then(() => {
      for (const animation of this.animations) {
        animation.reverse();
      }
    }).then(() => Promise.all(this.animations.map(animation => animation.ready))).then(callback);
  }
  progress(p) {
    for (const animation of this.animations) {
      const {
        activeDuration
      } = animation.effect.getComputedTiming();
      const {
        delay
      } = animation.effect.getTiming();
      animation.currentTime = ((delay || 0) + (activeDuration || 0)) * p;
    }
  }
  cancel() {
    for (const animation of this.animations) {
      animation.cancel();
    }
  }
  onFinish(callback) {
    Promise.all(this.animations.map(animation => animation.finished)).then(callback).catch(_error => {
      console.warn('animation was interrupted - aborting onFinish callback - ', _error);
    });
  }
}
function getInitialFrame(animation) {
  const preset = getNamedEffect(animation);
  if (preset && preset.initialFrame) {
    return preset.initialFrame(animation);
  }
  return null;
}
function getCSSAnimation(target, animationOptions, trigger) {
  const data = getEffectsData(animationOptions, target, undefined, true);
  const isViewProgress = (trigger == null ? void 0 : trigger.trigger) === 'view-progress';
  const initialFrame = getInitialFrame(animationOptions);
  return data.map((item, index) => {
    const {
      start,
      end
    } = isViewProgress ? getRanges(item.effect) : {};
    return {
      target: getAnimationTarget(target, item.part),
      animation: getAnimationAsCSS(item),
      id: item.id && `${item.id}-${index + 1}`,
      animationTimeline: isViewProgress ? `--${trigger == null ? void 0 : trigger.id}` : '',
      animationRange: start || end ? `${start} ${end}` : '',
      initialFrame
    };
  });
}
function getEffectsData(animation, target, options, asStyle) {
  // get the preset for the given animation options
  const namedEffect = getNamedEffect(animation);
  const animations = asStyle ? getCSSAnimationEffect(namedEffect, animation) : getWebAnimationEffect(namedEffect, animation, target, options);

  // process each (AnimationData|CSSAnimationData) object into a KeyframeEffect object
  return animations.map((effect, index) => {
    // prepare the KeyframeEffectOptions object
    const effectOptions = {
      fill: effect.fill,
      easing: getEasing(effect.easing),
      iterations: effect.iterations === 0 ? Infinity : effect.iterations || 1,
      composite: effect.composite,
      direction: getDirection(effect)
    };

    // if this is a TimeAnimation then set the duration and delay as time values
    if (effect.type.startsWith('Time')) {
      effectOptions.duration = effect.duration;
      effectOptions.delay = effect.delay || 0;
    } else {
      // if ViewTimeline is supported
      if (window.ViewTimeline) {
        // set duration to 'auto'
        effectOptions.duration = 'auto';
      } else {
        // if ViewTimeline not supported then put a 100ms value in duration get a progress we can easily relate to
        // we split the duration to 99.99ms and delay of 0.01ms to get the fill-mode effect working
        effectOptions.duration = 99.99;
        effectOptions.delay = 0.01;
      }
    }
    return {
      effect,
      options: effectOptions,
      id: animation.effectId && `${animation.effectId}-${index + 1}`,
      part: effect.part
    };
  });
}
function getWebAnimation(target, animationOptions, trigger, options) {
  const element = getElement(target);
  if ((trigger == null ? void 0 : trigger.trigger) === 'pointer-move') {
    let effectOptions = animationOptions;
    if (animationOptions.customEffect) {
      effectOptions = {
        ...animationOptions,
        namedEffect: {
          id: '',
          type: 'CustomMouse'
        }
      };
    }

    // TODO: need to fix the type here, currently lying about the returned type to be WebAnimationEffectFactory instead of MouseAnimationFactoryCreate
    const mouseAnimationPreset = getNamedEffect(effectOptions);
    const mouseAnimationFactory = getWebAnimationEffect(mouseAnimationPreset, animationOptions, element, options);
    return mouseAnimationFactory(element);
  }
  const data = getEffectsData(animationOptions, element, options);
  let timeline;
  const isViewProgress = (trigger == null ? void 0 : trigger.trigger) === 'view-progress';

  // if this is a ScrubAnimation with view-progress trigger and the browser supports the ViewTimeline API
  if (isViewProgress && window.ViewTimeline) {
    // generate the timeline object
    // @ts-expect-error
    timeline = new ViewTimeline({
      subject: trigger.element || getElement(trigger.componentId)
    });
  }

  // generate an Animation object for each data object
  const animations = data.map(_ref => {
    let {
      effect,
      options: effectOptions,
      id,
      part
    } = _ref;
    const effectTarget = part ? element == null ? void 0 : element.querySelector(`[data-motion-part~="${part}"]`) // maybe add ~ here as well
    : element;
    const keyframeEffect = new KeyframeEffect(effectTarget || null, [], effectOptions);

    // set the keyframes for the KeyframeEffect after measurements and mutations
    fastdom.mutate(() => {
      if ('timing' in effect) {
        keyframeEffect.updateTiming(effect.timing);
      }
      keyframeEffect.setKeyframes(effect.keyframes);
    });
    const animation = isViewProgress && timeline ? new Animation(keyframeEffect, timeline) : new Animation(keyframeEffect);

    // if this is a ScrubAnimation with view-progress trigger and the browser supports the ViewTimeline API
    if (isViewProgress) {
      if (timeline) {
        // set the ranges for the animation after measurements and mutations
        fastdom.mutate(() => {
          const {
            start,
            end
          } = getRanges(effect);
          // @ts-expect-error
          animation.rangeStart = start;
          // @ts-expect-error
          animation.rangeEnd = end;
          animation.play();
        });
      } else {
        const {
          startOffset,
          endOffset
        } = animationOptions;

        // set the ranges for the animation after measurements and mutations
        fastdom.mutate(() => {
          var _offset, _offset2;
          const startOffsetToWrite = effect.startOffset || startOffset;
          const endOffsetToWrite = effect.endOffset || endOffset;
          Object.assign(animation, {
            start: {
              name: startOffsetToWrite.name,
              offset: (_offset = startOffsetToWrite.offset) == null ? void 0 : _offset.value,
              add: effect.startOffsetAdd
            },
            end: {
              name: endOffsetToWrite.name,
              offset: (_offset2 = endOffsetToWrite.offset) == null ? void 0 : _offset2.value,
              add: effect.endOffsetAdd
            }
          });
        });
      }
    }
    if (id) {
      animation.id = id;
    }
    return animation;
  });

  // create an AnimationGroup with the generate animations
  return new AnimationGroup(animations, {
    ...animationOptions,
    trigger: {
      ...(trigger || {})
    },
    // make sure the group is ready after all animation targets are measured and mutated
    measured: new Promise(resolve => fastdom.mutate(resolve))
  });
}
function getElementAnimation(target, effectId) {
  const element = typeof target === 'string' ? getElement(target) : target;
  // somehow get the right animations
  const animations = element == null ? void 0 : element.getAnimations().filter(anim => {
    // @ts-expect-error
    const id = anim.id || anim.animationName;
    // if no id/name just return all animations
    return id ? id.startsWith(effectId) : true;
  });
  return animations != null && animations.length ? new AnimationGroup(animations) : null;
}
function getScrubScene(target, animationOptions, trigger, sceneOptions) {
  if (sceneOptions === void 0) {
    sceneOptions = {};
  }
  const {
    disabled,
    ...rest
  } = sceneOptions;
  const animation = getWebAnimation(target, animationOptions, trigger, rest);
  let typeSpecificOptions = {};
  if (trigger.trigger === 'view-progress' && !window.ViewTimeline) {
    // TODO(ameerf): consider doing this only for bgscrub to not affect the other scroll effects
    const viewSource = trigger.element || getElement(trigger.componentId);
    const {
      ready
    } = animation;
    return animation.animations.map(partialAnimation => {
      return {
        /* we use getters for start and end in order to access the animation's start and end
           only when initializing the scrub scene rather than immediately */
        get start() {
          return partialAnimation.start;
        },
        get end() {
          return partialAnimation.end;
        },
        viewSource,
        ready,
        getProgress() {
          return animation.getProgress();
        },
        effect(__, p) {
          const {
            activeDuration
          } = partialAnimation.effect.getComputedTiming();
          const {
            delay
          } = partialAnimation.effect.getTiming();
          partialAnimation.currentTime = ((delay || 0) + (activeDuration || 0)) * p;
        },
        disabled,
        destroy() {
          partialAnimation.cancel();
        }
      };
    });
  } else if (trigger.trigger === 'pointer-move') {
    const {
      centeredToTarget,
      transitionDuration,
      transitionEasing
    } = animationOptions;
    typeSpecificOptions = {
      target: animation.target,
      centeredToTarget
    };
    if (animationOptions.customEffect && transitionDuration) {
      typeSpecificOptions.transitionDuration = transitionDuration;
      typeSpecificOptions.transitionEasing = getJsEasing(transitionEasing);
    }
  }
  return {
    ...typeSpecificOptions,
    getProgress() {
      return animation.getProgress();
    },
    effect(__, p, v) {
      // @ts-expect-error the type of `p` is dependent on the value of `trigger.trigger`
      animation.progress(v ? {
        ...p,
        v
      } : p);
    },
    disabled,
    destroy() {
      animation.cancel();
    }
  };
}
function prepareAnimation(target, animation) {
  const preset = getNamedEffect(animation);
  if (preset && preset.prepare && target) {
    const domApi = {
      measure: measure(target),
      mutate: mutate(target)
    };
    preset.prepare(animation, domApi);
  }
}
export { getCSSAnimation, getWebAnimation, getElementAnimation, getScrubScene, prepareAnimation };
//# sourceMappingURL=motion.js.map