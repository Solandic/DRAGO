export { initialFrame } from './common';
const PARAMS_MAP = {
  pseudoRight: {
    rotationX: '180',
    rotationY: '0'
  },
  right: {
    rotationX: '0',
    rotationY: '180'
  },
  pseudoLeft: {
    rotationX: '-180',
    rotationY: '0'
  },
  left: {
    rotationX: '0',
    rotationY: '-180'
  }
};
export function web(options, dom) {
  const animationStyle = style(options);
  prepare(options, dom);
  return [{
    ...animationStyle[0],
    easing: 'quadOut',
    keyframes: [{
      opacity: 0,
      transform: `perspective(200px) translateZ(calc(var(--motion-width, 300px) * -3)) rotateX(${animationStyle[0].custom['--motion-rotate-x']}) rotateY(${animationStyle[0].custom['--motion-rotate-y']}) translateZ(calc(var(--motion-width, 300px) * 3)) rotateZ(var(--comp-rotate-z, 0deg))`
    }, {
      opacity: 'var(--comp-opacity, 1)',
      transform: `perspective(200px) translateZ(calc(var(--motion-width, 300px) * -3)) rotateX(0deg) rotateY(0deg) translateZ(calc(var(--motion-width, 300px) * 3)) rotateZ(var(--comp-rotate-z, 0deg))`
    }]
  }];
}
export function style(options) {
  const {
    direction = 'right'
  } = options.namedEffect;
  const {
    rotationX,
    rotationY
  } = PARAMS_MAP[direction];
  return [{
    ...options,
    name: 'curveIn',
    easing: 'quadOut',
    custom: {
      '--motion-rotate-x': `${rotationX}deg`,
      '--motion-rotate-y': `${rotationY}deg`
    }
  }];
}
export function prepare(_, dom) {
  if (dom) {
    dom.measure(target => {
      if (!target) {
        return;
      }
      const width = target.getBoundingClientRect().width;
      dom.mutate(target_ => {
        target_ == null || target_.style.setProperty('--motion-width', `${width}px`);
      });
    });
  }
}
//# sourceMappingURL=CurveIn.js.map