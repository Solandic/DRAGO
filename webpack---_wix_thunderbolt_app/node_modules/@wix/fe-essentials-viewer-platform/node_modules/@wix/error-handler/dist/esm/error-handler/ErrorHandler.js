import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { reportErrorBi } from './reportErrorBi';
import { createErrorResolution } from './createErrorResolution';
import { createBiLoggerWithDefaults } from '../util/createBiLoggerWithDefaults';
import { ErrorAccessor } from '../state/ErrorAccessor';
import { TranslationsState } from '../state/TranslationsState';
import { reportErrorResolutionBi } from './reportErrorResolutionBi';
import { v4 as uuid } from 'uuid';
import { reportGetResolvedErrorBi } from './reportGetResolvedErrorBi';
import { reportShowErrorBi } from './reportShowErrorBi';
import { CommonErrorsMapState } from '../state/CommonErrorsMapState';
export class ErrorHandler {
  constructor(params) {
    _defineProperty(this, "biLogger", void 0);
    _defineProperty(this, "errorMonitor", void 0);
    _defineProperty(this, "experiments", void 0);
    _defineProperty(this, "platformShowError", void 0);
    _defineProperty(this, "translations", void 0);
    _defineProperty(this, "commonErrorsMapState", void 0);
    _defineProperty(this, "onlineManager", void 0);
    _defineProperty(this, "webWindow", void 0);
    _defineProperty(this, "handleError", async error => {
      if (this._isErrorHandlerDisabled()) {
        return;
      }
      const {
        errorMonitor
      } = this;
      try {
        const errorAccessor = new ErrorAccessor({
          error
        });
        this._setErrorHandlerSessionId(errorAccessor);
        reportErrorBi(this, {
          errorAccessor
        });
      } catch (e) {
        console.error(e);
        errorMonitor.captureException(e);
      }
    });
    _defineProperty(this, "withErrorHandler", async (fn, options) => {
      try {
        return await fn();
      } catch (error) {
        this._setErrorHandlerErrorCodesMap(error, options);
        await this.commonErrorsMapState._initPromise;
        throw error;
      }
    });
    _defineProperty(this, "getResolvedError", error => {
      const {
        errorMonitor
      } = this;
      try {
        const errorAccessor = new ErrorAccessor({
          error
        });
        const {
          applicationError,
          validationError,
          httpError,
          error: e
        } = errorAccessor;
        const errorResolution = this._resolveError(errorAccessor);
        const resolvedError = e == null ? void 0 : e._errorHandlerResolvedError;
        reportGetResolvedErrorBi(this, {
          errorAccessor,
          errorResolution
        });
        return {
          message: (resolvedError == null ? void 0 : resolvedError.message) ?? "This action wasn't completed due to a technical issue.",
          action: resolvedError == null ? void 0 : resolvedError.action,
          validationError,
          applicationError: applicationError,
          httpError,
          requestId: httpError == null ? void 0 : httpError.requestId
        };
      } catch (e) {
        console.error(e);
        errorMonitor.captureException(e);
        throw e;
      }
    });
    _defineProperty(this, "showError", (error, props) => {
      const {
        platformShowError,
        errorMonitor
      } = this;
      if (!platformShowError) {
        return;
      }
      try {
        const errorAccessor = new ErrorAccessor({
          error
        });
        const {
          error: e
        } = errorAccessor;
        this._resolveError(errorAccessor);
        const resolvedError = e == null ? void 0 : e._errorHandlerResolvedError;
        const showErrorProps = {
          ...resolvedError,
          ...props
        };
        reportShowErrorBi(this, {
          showErrorProps,
          errorAccessor
        });
        if (!showErrorProps) {
          return;
        }
        const {
          message,
          action,
          ...restShowErrorParams
        } = showErrorProps;
        if (!message) {
          return;
        }
        platformShowError({
          ...restShowErrorParams,
          message,
          action: action != null && action.onClick ? {
            text: action.text,
            onClick: action.onClick
          } : undefined
        });
      } catch (e) {
        console.error(e);
        errorMonitor.captureException(e);
      }
    });
    this.biLogger = createBiLoggerWithDefaults(params);
    this.errorMonitor = params.createErrorMonitor({
      dsn: 'https://831e1d96e7944c6aae0c9ed9d6babd35@sentry.wixpress.com/5896'
    });
    this.experiments = params.createExperiments == null ? void 0 : params.createExperiments({
      scopes: ['error-handler']
    });
    this.platformShowError = params.showError;
    this.translations = new TranslationsState(params);
    this.onlineManager = params.onlineManager ?? (typeof navigator !== 'undefined' ? navigator : {
      onLine: true
    });
    this.webWindow = params.webWindow ?? (typeof window !== 'undefined' ? window : undefined);
    this.commonErrorsMapState = new CommonErrorsMapState(this);
  }
  _setErrorHandlerSessionId(errorAccessor) {
    const {
      error
    } = errorAccessor;
    if (!error) {
      return;
    }
    error._errorHandlerSessionId = uuid();
  }
  _setErrorHandlerResolvedError(errorAccessor, errorResolution) {
    const {
      error
    } = errorAccessor;
    if (!error) {
      return;
    }
    error._errorHandlerResolvedError = errorResolution.errorToShow;
  }
  _setErrorHandlerErrorCodesMap(error, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      errorCodesMap
    } = options;
    const errorAccessor = new ErrorAccessor({
      error
    });
    reportErrorResolutionBi(this, {
      errorAccessor,
      errorCodesMap
    });
    const {
      error: e
    } = errorAccessor;
    if (!e) {
      return;
    }
    e._errorHandlerErrorCodesMap = errorCodesMap;
  }
  _isErrorHandlerDisabled() {
    const {
      experiments
    } = this;
    return experiments != null && !experiments.enabled('specs.os.EnableErrorHandlerInEditor');
  }
  _resolveError(errorAccessor, options) {
    var _errorAccessor$error;
    if (options === void 0) {
      options = {};
    }
    if (this._isErrorHandlerDisabled()) {
      return;
    }
    const errorCodesMap = options.errorCodesMap ?? ((_errorAccessor$error = errorAccessor.error) == null ? void 0 : _errorAccessor$error._errorHandlerErrorCodesMap);
    const errorResolution = createErrorResolution(this, {
      errorAccessor,
      errorCodesMap
    });
    this._setErrorHandlerResolvedError(errorAccessor, errorResolution);
    return errorResolution;
  }
  toJSON() {
    return {};
  }
}
//# sourceMappingURL=ErrorHandler.js.map