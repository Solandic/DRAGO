import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { resolveFromMapping } from '../util/resolveFromMapping';
export class ErrorResolution {
  constructor(params) {
    _defineProperty(this, "errorAccessor", void 0);
    _defineProperty(this, "errorCodesMap", void 0);
    _defineProperty(this, "commonErrorsMapState", void 0);
    _defineProperty(this, "onlineManager", void 0);
    _defineProperty(this, "consumerResolvedError", void 0);
    _defineProperty(this, "commonResolvedError", void 0);
    this.commonErrorsMapState = params.commonErrorsMapState;
    this.errorAccessor = params.errorAccessor;
    this.errorCodesMap = params.errorCodesMap;
    this.onlineManager = params.onlineManager;
  }
  get commonErrors() {
    return this.commonErrorsMapState.commonErrors;
  }
  _resolveNetworkError() {
    const {
      onlineManager,
      commonErrors,
      errorAccessor
    } = this;
    if (!commonErrors) {
      return null;
    }
    if (onlineManager.onLine) {
      return commonErrors.getNetworkErrorShowErrorProps(errorAccessor);
    }
    return commonErrors.connectionErrorShowErrorProps;
  }
  _resolveCommonError() {
    const {
      errorAccessor,
      commonErrors,
      errorCodesMap
    } = this;
    const {
      httpError,
      validationError
    } = errorAccessor;
    if (httpError == null) {
      return this._resolveNetworkError();
    }
    if (!commonErrors) {
      return null;
    }
    if (validationError) {
      var _commonErrors$commonE;
      return (_commonErrors$commonE = commonErrors.commonErrorsMap.statusCodeError) == null || _commonErrors$commonE.INVALID_ARGUMENT == null ? void 0 : _commonErrors$commonE.INVALID_ARGUMENT(httpError);
    }
    const resolvedError = resolveFromMapping({
      errorAccessor,
      httpError,
      errorCodesMap: commonErrors.commonErrorsMap
    });
    if (!resolvedError) {
      return (errorCodesMap == null || errorCodesMap.serverError == null ? void 0 : errorCodesMap.serverError(httpError)) ?? commonErrors.defaultErrorShowErrorProps;
    }
    return resolvedError;
  }
  _resolveConsumerError() {
    const {
      errorCodesMap,
      errorAccessor
    } = this;
    const {
      httpError
    } = errorAccessor;
    if (httpError == null || errorCodesMap == null) {
      return null;
    }
    return resolveFromMapping({
      errorAccessor,
      errorCodesMap,
      httpError
    });
  }
  resolve() {
    this.consumerResolvedError = this._resolveConsumerError();

    // If consumer resolved the error, we don't need to resolve the common error
    if (this.consumerResolvedError != null) {
      return;
    }
    this.commonResolvedError = this._resolveCommonError();
  }
  get errorToShow() {
    return this.consumerResolvedError ?? this.commonResolvedError;
  }
}
//# sourceMappingURL=ErrorResolution.js.map